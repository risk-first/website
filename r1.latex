% Page setup
\documentclass[12pt]{memoir}
\setstocksize{9.69in}{7.44in}
\settrimmedsize{\stockheight}{\stockwidth}{*}
\setlrmarginsandblock{3.5cm}{2.5cm}{*}
\setulmarginsandblock{2cm}{3cm}{*}
\checkandfixthelayout 
\setheadfoot{\onelineskip}{2\onelineskip}

% Activate to begin paragraphs with an empty line rather than an indent
\usepackage{parskip}    	
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}	

\usepackage{graphicx}					
\usepackage{amssymb}

%SetFonts
\usepackage[T1]{fontenc}
\usepackage{newpxtext,newpxmath}

%Images
\usepackage{graphicx}
% We will generate all images so they have a width .8\maxwidth. This means
% that they will get their normal width if they fit onto the page, but
% are scaled down if they would overflow the margins.
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth
\else\Gin@nat@width\fi}
\makeatother
\let\Oldincludegraphics\includegraphics
\renewcommand{\includegraphics}[1]{\Oldincludegraphics[width=.9\maxwidth]{#1}}
\usepackage{rotating}
\usepackage[margin=10pt,font=small,labelfont=bf]{caption}
\captionsetup[figure]{labelfont={bf,it},textfont={bf,it}}


% Links
\usepackage[unicode=true]{hyperref}
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={},
            pdftitle={},
            colorlinks=false,
            urlcolor=black,
            linkcolor=black,
            pdfborder={0 0 0}}

% Footers / Page Numbers            (FIX ME)
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhead{}
  \renewcommand{\headrulewidth}{0pt}
  \fancyfoot[LE, RO]{\thepage}
  \fancyfoot[C]{\textsl}

% Tables            
\usepackage{longtable,booktabs}
\usepackage[width=.8\textwidth]{caption}
% These lines are needed to make table captions work with longtable:
\makeatletter
\def\fnum@table{\tablename~\thetable}
\makeatother
\usepackage{rotating}

% Code Sections
\usepackage{listings}
\newcommand{\passthrough}[1]{#1}
\lstnewenvironment{code}{\lstset{basicstyle=\small\ttfamily}}{}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}


%Links as Notes
\DeclareRobustCommand{\href}[2]{#2\footnote{\url{#1}}}
 \renewcommand{\footnotesize}{\fontsize{6.5pt}{8.5pt}\selectfont}

%Sections
\chapterstyle{veelo}
\setlength{\beforechapskip}{20pt}
\setsechook{\hangsecnum}
\setcounter{secnumdepth}{5}

\begin{document}

\frontmatter

\title{Risk-First Software Development: The Menagerie}
\author{Rob Moffat}

\begin{titlingpage}

\hspace{0.05\textwidth}

\centering

{\Huge\bfseries\textsc{Risk-First}}\\[2\baselineskip]

{\Huge\bfseries\textsc{Software Development De-Risked }}\\[2\baselineskip]

{\Huge\textit{Volume 1: The Menagerie}}\\[7\baselineskip]

{\Oldincludegraphics[width=0.5\textwidth]{images/R1_logo_grue.png}}\\[7\baselineskip]

{\Huge\textsc{Rob Moffat}}


\end{titlingpage}

\hypertarget{risk-first-the-menagerie}{%
\section{Risk First: The Menagerie}\label{risk-first-the-menagerie}}

By Rob Moffat

Copyright © 2018 Kite9 Ltd.

All rights reserved. No part of this publication may be reproduced,
distributed, or transmitted in any form or by any means, including
photocopying, recording, or other electronic or mechanical methods,
without the prior written permission of the publisher, except in the
case of brief quotations embodied in critical reviews and certain other
noncommercial uses permitted by copyright law. For permission requests,
write to the publisher, addressed ``Attention: Permissions
Coordinator,'' at the address below.

ISBN: tbd.

\hypertarget{credits}{%
\subsection{Credits}\label{credits}}

tbd

Cover Images: Biodiversity Heritage Library. Biologia
Centrali-Americana. Insecta. Rhynchota. Hemiptera-Homoptera. Volume 1
(1881-1905)

Cover Design By P. Moffat (\texttt{peter@petermoffat.com})

Thanks to:

\hypertarget{books-in-the-series}{%
\subsection{Books In The Series}\label{books-in-the-series}}

\begin{itemize}
\tightlist
\item
  \textbf{Risk First: The Menagerie:} Book one of the
  \textbf{Risk-First} series argues the case for viewing \emph{all} of
  the activities on a software project through the lens of
  \emph{managing risk}. It introduces the menagerie of different risks
  you're likely to meet on a software project, naming and classifying
  them so that we can try to understand them better.
\item
  \textbf{Risk First: Tools and Practices:} Book two of the \textbf{Risk
  First} series explores the relationship between software project risks
  and the tools and practices we use to mitigate them. Due for
  publication in 2020.
\end{itemize}

\hypertarget{online}{%
\subsection{Online}\label{online}}

Material for the books is freely available to read, drawn from
\texttt{risk-first.org}.

\hypertarget{published-by}{%
\subsection{Published By}\label{published-by}}

\begin{verbatim}
Kite9 Ltd.
14 Manor Close
Colchester
CO6 4AR
\end{verbatim}

\setcounter{tocdepth}{0}
\tableofcontents

\hypertarget{preface}{%
\chapter{Preface}\label{preface}}

Welcome to Risk-First!

Let's cover some of the big questions up-front: The why, what, who, how
and where of \emph{The Menagerie}.

\hypertarget{why}{%
\section{Why}\label{why}}

\begin{quote}
``Scrum, Waterfall, Lean, Prince2: what do they all have in common?''
\end{quote}

I've started this because, on my career journey, I've noticed that the
way I do things doesn't seem to match up with the way the books
\emph{say} it should be done. And, I found this odd and wanted to
explore it further. Hopefully, you, the reader, will find something of
use in this.

I started with this observation: \emph{Development Teams} put a lot of
faith in methodology. Sometimes, this faith is often so strong it
borders on religion. (Which in itself is a concern.) For some, this is
Prince2. For others, it might be Lean or Agile.

\emph{Developers} put a lot of faith in \emph{particular tools} too.
Some developers are pro-or-anti-Java, others are pro-or-anti-XML. All of
them have their views coloured by their \emph{experiences} (or lack of)
with these tools. Was this because their past projects \emph{succeeded}
or \emph{failed} because of them?

As time went by, I came to see that the choice of methodology, process
or tool was contingent on the problem being solved, and the person
solving the problem. We don't face a shortage of tools in IT, or a
shortage of methodologies, or a shortage of practices. Essentially, that
all the tools and methodologies that the industry had supplied were
there to help \emph{minimize the risk of my project failing}.

This book considers that perspective: that building software is all
about \emph{managing risk}, and that these methodologies are
acknowledgements of this fact, and they differ because they have
\emph{different ideas} about which are the most important \emph{risks to
manage}.

\hypertarget{what-this-is}{%
\section{What This Is}\label{what-this-is}}

Hopefully, after reading this, you'll come away with:

\begin{itemize}
\tightlist
\item
  An appreciation of how risk underpins everything we do as developers,
  whether we want it to or not.
\item
  A framework for evaluating methodologies, tools and practices and
  choosing the right one for the task-at-hand.
\item
  A recontextualization of the software process as being an exercise in
  mitigating different kinds of risk.
\item
  The tools to help you decide when a methodology or tool is
  \emph{letting you down}, and the vocabulary to argue for when it's a
  good idea to deviate from it.
\end{itemize}

This is not intended to be a rigorously scientific work: I don't believe
it's possible to objectively analyze a field like software development
in any meaningful, statistically significant way. (For one, things just
change too fast.)

\begin{quote}
``I have this Pattern''
\end{quote}

Does that diminish it? If you have visited the TVTropes website, you'll
know that it's a set of web-pages describing \emph{common patterns} of
narrative, production, character design etc. to do with fiction. For
example:

\begin{quote}
tbd.
\end{quote}

Is it scientific? No.~Is it correct? Almost certainly. TVTropes is a set
of \emph{empirical patterns} for how stories on TV and other media work.
It's really useful, and a lot of fun. (Warning: it's also incredibly
addictive).

In the same way, tbd, the tbd published a book called ``Design Patterns:
tbd''. Which shows you patterns of \emph{structure} within
Object-Oriented programming:

\begin{quote}
tbd.
\end{quote}

\hypertarget{patterns-for-practitioners}{%
\subsection{Patterns For
Practitioners}\label{patterns-for-practitioners}}

This book aimed to be a set of \emph{useful} patterns which
practitioners could use in their software to achieve certain goals. ``I
have this pattern'' was a phrase used to describe how they had seen a
certain set of constraints before, and how they had solved it in
software.

This book was a set of experts handing down their battle-tested
practices for other developers to use, and, whether you like patterns or
not, knowing them is an important part of being a software developer, as
you will see them used everywhere you go and probably use them yourself.

In the same way, this book aims to be a set of \emph{Patterns for
Software Risk}. Hopefully after reading this book, you will see where
risk hides in software projects, and have a name for it when you see it.

\hypertarget{towards-a-periodic-table}{%
\subsection{Towards a ``Periodic
Table''}\label{towards-a-periodic-table}}

In the latter chapters of ``The Menagerie'' we try to assemble these
risk patterns into a cohesive whole. Projects fail because of risks, and
risks arise from predictable sources.

\hypertarget{what-this-is-not}{%
\subsection{What This is Not}\label{what-this-is-not}}

This is not intended to be a rigorously scientific work: I don't believe
it's possible to objectively analyze a field like software development
in any meaningful, statistically significant way. (For one, things just
change too fast.)

Neither is this site isn't going to be an exhaustive guide of every
possible software development practice and methodology. That would just
be too long and tedious.

Neither is this really a practitioner's guide to using any particular
methodology: If you've come here to learn the best way to do
Retrospectives, then you're in the wrong place. There are plenty of
places you can find that information already. Where possible, this site
will link to or reference concepts on Wikipedia or the wider internet
for further reading on each subject.

\hypertarget{who}{%
\section{Who}\label{who}}

This work is intended to be read by people who work on software
projects, and especially those who are involved in managing software
projects.

If you work collaboratively with other people in a software process, you
should find Risk-First a useful lexicon of terms to help describe the
risks you face.

But here's a warning: This is going to be a depressing book to read. It
is book one of a two-book series, but in \textbf{Book One} you only get
to meet the bad guy.

While \textbf{Book Two} is all about \emph{how to succeed}, This book is
all about how projects \emph{fail}. In it, we're going to try and put
together a framework for understanding the risk of failure, in order
that we can reconstruct our understanding of our activities on a project
based on avoiding it.

So, if you are interested in \emph{avoiding your project failing}, this
is probably going to be useful knowledge.

\hypertarget{for-developers}{%
\subsection{For Developers}\label{for-developers}}

Risk-First is a tool you can deploy to immediately improve your ability
to plan your work.

Frequently, as developers we find software methodologies ``done to us''
from above. Risk-First is a toolkit to help \emph{take apart}
methodologies like Scrum, Lean and Prince2, and understand them.
Methodologies are \emph{bicycles}, rather than \emph{religions}. Rather
than simply \emph{believing}, we can take them apart and see how they
work.

\hypertarget{for-project-managers-and-team-leads}{%
\subsection{For Project Managers and Team
Leads}\label{for-project-managers-and-team-leads}}

All too often, Project Managers don't have a full grasp of the technical
details of their projects. And this is perfectly normal, as the
specialization belongs below them. However, projects fail because risks
materialize, and risks materialize because the devil is in those
details.

This seems like a lost cause, but there is hope: the ways in which risks
materialize on technical projects is the same every time. With
Risk-First we are attempting to name each of these types of risk, which
allows for a dialog with developers about which risks they face, and the
order they should be tackled.

Risk-First allows a project manager to pry open the black box of
development and talk with developers about their work, and how it will
affect the project. It is another tool in the (limited) arsenal of
techniques a project manager can bring to bear on the task of delivering
a successful project.

\hypertarget{how}{%
\section{How}\label{how}}

One of the original proponents of the Agile Manifesto, Kent Beck, begins
his book Extreme Programming by stating:

``It's all about risk'' \textgreater{} Kent Beck

This is a promising start. From there, he introduces his methodology,
Extreme Programming, and explains how you can adopt it in your team, the
features to observe and the characteristics of success and failure.
However, while \emph{Risk} has clearly driven the conception of Extreme
Programming, there is no clear model of software risk underpinning the
work, and the relationship between the practices he espouses and the
risks he is avoiding are hidden.

In this book, we are going to introduce a model of software project
risk. This means that in \textbf{Book Two} (Risk-First: Tools and
Practices), we can properly analyse Extreme Programming (and Scrum,
Waterfall, Lean and all the others) and \emph{understand} what drives
them. Since they are designed to deliver successful software projects,
they must be about mitigate risks, and we will uncover \emph{exactly
which risks are mitigated} and \emph{how they do it}.

\hypertarget{where}{%
\section{Where}\label{where}}

All of the material for this book is available Open Source on
\href{https://github.com}{github.com}, and at the
\href{https://risk-first.org}{risk-first.org} website. Please visit,
your feedback is appreciated.

There is no compulsion to buy a print or digital version of the book,
but we'd really appreciate the support. So, if you've read this and
enjoyed it, how about buying a copy for someone else to read?

\hypertarget{a-note-on-references}{%
\subsection{A Note on References}\label{a-note-on-references}}

Where possible, references are to the
\href{https://wikipedia.org}{Wikipedia} website. Wikipedia is not
perfect. There is a case for linking to the original articles and
papers, but by using Wikipedia references are free and easy for everyone
to access, and hopefully will exist for a long time into the future.

On to The Executive Summary

\hypertarget{executive-summary}{%
\chapter{Executive Summary}\label{executive-summary}}

\hypertarget{there-are-lots-of-ways-of-running-software-projects}{%
\section{1. There are Lots of Ways of Running Software
Projects}\label{there-are-lots-of-ways-of-running-software-projects}}

There are lots of different ways to look at a project. For example,
metrics such as ``number of open tickets'', ``story points'', ``code
coverage'' or ``release cadence'' give us a numerical feel for how
things are going and what needs to happen next. We also judge the health
of projects by the practices used on them - Continuous Integration, Unit
Testing or Pair Programming, for example.

Software methodologies, then, are collections of tools and practices:
``Agile'', ``Waterfall'', ``Lean'' or ``Phased Delivery'' (for example)
all suggest different approaches to running a project, and are
opinionated about the way they think projects should be done and the
tools that should be used.

None of these is necessarily more ``right'' than another- they are
suitable on different projects at different times.

A key question then is: \textbf{how do we select the right tools for the
job?}

\hypertarget{we-can-look-at-projects-in-terms-of-risks}{%
\section{2. We can Look at Projects in Terms of
Risks}\label{we-can-look-at-projects-in-terms-of-risks}}

One way to examine a project in-flight is by looking at the risks it
faces.

Commonly, tools such as RAID logs and RAG status reporting are used.
These techniques should be familiar to project managers and developers
everywhere.

However, the Risk-First view is that we can go much further: that each
item of work being done on the project is mitigating a particular risk.
Risk isn't something that just appears in a report, it actually drives
\emph{everything we do}.

For example:

\begin{itemize}
\tightlist
\item
  A story about improving the user login screen can be seen as reducing
  \emph{the risk of users not signing up}.
\item
  A task about improving the health indicators could be seen as
  mitigating \emph{the risk of the application failing and no-one
  reacting to it}.
\item
  Even a task as basic as implementing a new function in the application
  is mitigating \emph{the risk that users are dissatisfied and go
  elsewhere}.
\end{itemize}

\textbf{One assertion of Risk-First therefore, is that every action you
take on a project is to mitigate some risk.}

\hypertarget{we-can-break-down-risks-on-a-project-methodically}{%
\section{3. We Can Break Down Risks on a Project
Methodically}\label{we-can-break-down-risks-on-a-project-methodically}}

Although risk is usually complicated and messy, other industries have
found value in breaking down the types of risks that affect them and
addressing them individually.

For example:

\begin{itemize}
\tightlist
\item
  In manufacturing, \emph{tolerances} allow for calculating the
  likelihood of defects in production.
\item
  In finance, reserves are commonly set aside for the risks of
  stock-market crashes, and teams are structured around monitoring these
  different risks.
\item
  The insurance industry is founded on identifying particular risks and
  providing financial safety-nets for when they occur, such as death,
  injury, accident and so on.
\end{itemize}

Software risks are difficult to quantify, and mostly, the effort
involved in doing so \emph{exactly} would outweigh the benefit.
Nevertheless, there is value in spending time building
\emph{classifications of risk for software}. That's what Risk-First
does: describes the set of \emph{risk patterns} we see every day on
software projects.

With this in place, we can:

\begin{itemize}
\tightlist
\item
  Talk about the types of risks we face on our projects, using an
  appropriate language.
\item
  Expose Hidden Risks that we hadn't considered before.
\item
  Weigh the risks against each other, and decide which order to tackle
  them.
\end{itemize}

\hypertarget{we-can-analyse-tools-and-techniques-in-terms-of-how-they-mitigate-risk}{%
\section{4. We Can Analyse Tools and Techniques in Terms of how they
Mitigate
Risk}\label{we-can-analyse-tools-and-techniques-in-terms-of-how-they-mitigate-risk}}

If we accept the assertion above that \emph{all} the actions we take on
a project are about mitigating risks, then it stands to reason that the
tools and techniques available to us on a project are there for
mitigating different types of risks.

For example:

\begin{itemize}
\tightlist
\item
  If we do a Code Review, we are partly trying to mitigate the risks of
  bugs slipping through into production, and also mitigate the Key-Man
  Risk of knowledge not being widely-enough shared.
\item
  If we write Unit Tests, we're also mitigating the risk of bugs going
  to production, but we're also mitigating against future changes
  breaking our existing functionality.
\item
  If we enter into a contract with a supplier, we are mitigating the
  risk of the supplier vanishing and leaving us exposed. With the
  contract in place, we have legal recourse against this risk.
\end{itemize}

\textbf{Different tools are appropriate for mitigating different types
of risks.}

\hypertarget{different-methodologies-for-different-risk-profiles}{%
\section{5. Different Methodologies for Different Risk
Profiles}\label{different-methodologies-for-different-risk-profiles}}

In the same way that our tools and techniques are appropriate to dealing
with different risks, the same is true of the methodologies we use on
our projects. We can use a Risk-First approach to examine the different
methodologies, and see which risks they address.

For example:

\begin{itemize}
\tightlist
\item
  \textbf{Agile} methodologies prioritise mitigating the risk that
  requirements capture is complicated, error-prone and that requirements
  change easily.
\item
  \textbf{Waterfall} takes the view that coding effort is an expensive
  risk, and that we should build plans up-front to avoid it.
\item
  \textbf{Lean} takes the view that risk lies in incomplete work and
  wasted work, and aims to minimize that.
\end{itemize}

Although many developers have a methodology-of-choice, the argument here
is that there are tradeoffs with all of these choices. Methodologies are
like \emph{bicycles}, rather than \emph{religions}. Rather than simply
\emph{believing}, we can take them apart and see how they work.

\textbf{We can place methodologies within a framework, and show how
choice of methodology is contingent on the risks faced.}

\hypertarget{driving-development-with-a-risk-first-perspective}{%
\section{6. Driving Development With a Risk-First
Perspective}\label{driving-development-with-a-risk-first-perspective}}

We have described a model of risk within software projects, looking
something like this:

\begin{figure}
\centering
\includegraphics{images/generated/pattern_language-400dpi.png}
\caption{Methdologies, Risks, Practices}
\end{figure}

How do we take this further?

The first idea we explore is that of the Risk Landscape: Although the
software team can't remove risk from their project, they can take
actions that move them to a place in the Risk Landscape where the risks
on the project are more favourable than where they started.

From there, we examine basic risk archetypes you will encounter on the
software project, to build up a Taxonomy of Software Risk, and look at
which specific tools you can use to mitigate each kind of risk.

Then, we look at different software practices, and how they mitigate
various risks. Beyond this we examine the question: \emph{how can a
Risk-First approach inform the use of this technique?}

For example:

\begin{itemize}
\tightlist
\item
  If we are introducing a \textbf{Sign-Off} in our process, we have to
  balance the risks it \emph{mitigates} (coordination of effort, quality
  control, information sharing) with the risks it \emph{introduces}
  (delays and process bottlenecks).
\item
  If we have \textbf{Redundant Systems}, this mitigates the risk of a
  \emph{single point of failure}, but introduces risks around
  \emph{synchronizing data} and \emph{communication} between the
  systems.
\item
  If we introduce \textbf{Process}, this may make it easier to
  \emph{coordinate as a team} and \emph{measure performance} but may
  lead to bureaucracy, focusing on the wrong goals or over-rigid
  interfaces to those processes.
\end{itemize}

Risk-First aims to provide a framework in which we can \emph{analyse
these choices} and weigh up \emph{accepting} versus \emph{mitigating}
risks.

\textbf{Still interested? Then dive into reading the introduction.}

\mainmatter
\part{Introduction}

\part{Risk}

\hypertarget{software-dependency-risk}{%
\chapter{Software Dependency Risk}\label{software-dependency-risk}}

In this section, we're going to look specifically at \emph{Software}
dependencies, although many of the concerns we'll raise here apply
equally to all the other types of dependency we outlined in Dependency
Risk.

\hypertarget{kolmogorov-complexity-cheating}{%
\section{Kolmogorov Complexity:
Cheating}\label{kolmogorov-complexity-cheating}}

In the earlier section on Complexity Risk we tackled Kolmogorov
Complexity, and the idea that your codebase had some kind of minimal
level of complexity based on the output it was trying to create. This is
a neat idea, but in a way, we cheated. Let's look at how.

We were trying to figure out the shortest (Javascript) program to
generate this output:

\begin{verbatim}
abcdabcdabcdabcdabcdabcdabcdabcdabcdabcd
\end{verbatim}

And we came up with this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ ABCD}\OperatorTok{=}\StringTok{"ABCD"}\OperatorTok{;}\NormalTok{                                           (}\DecValTok{11}\NormalTok{ symbols)}

\KeywordTok{function} \AttributeTok{out}\NormalTok{() }\OperatorTok{\{}\NormalTok{                                             (}\DecValTok{7}\NormalTok{ symbols)}
    \ControlFlowTok{return} \VariableTok{ABCD}\NormalTok{.}\AttributeTok{repeat}\NormalTok{(}\DecValTok{10}\NormalTok{)                                   (}\DecValTok{7}\NormalTok{ symbols)}
\OperatorTok{\}}\NormalTok{                                                            (}\DecValTok{1}\NormalTok{ symbol)}
\end{Highlighting}
\end{Shaded}

Which had \textbf{26} symbols in it.

Now, here's the cheat: The \texttt{repeat()} function was built into
Javascript in 2015 in
\href{http://www.ecma-international.org/ecma-262/6.0/}{ECMAScript 6.0}.
If we'd had to program it ourselves, we might have added this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \AttributeTok{repeat}\NormalTok{(s}\OperatorTok{,}\NormalTok{n) }\OperatorTok{\{}\NormalTok{                                       (}\DecValTok{10}\NormalTok{ symbols)}
    \KeywordTok{var}\NormalTok{ a}\OperatorTok{=}\NormalTok{[]}\OperatorTok{;}\NormalTok{                                                (}\DecValTok{7}\NormalTok{ symbols)}
    \ControlFlowTok{while}\NormalTok{(}\VariableTok{a}\NormalTok{.}\AttributeTok{length}\OperatorTok{<}\NormalTok{n)}\OperatorTok{\{}\NormalTok{                                       (}\DecValTok{9}\NormalTok{ symbols)}
        \VariableTok{a}\NormalTok{.}\AttributeTok{push}\NormalTok{(s)                                            (}\DecValTok{6}\NormalTok{ symbols)}
    \OperatorTok{\}}\NormalTok{                                                        (}\DecValTok{1}\NormalTok{ symbol)}
    \ControlFlowTok{return} \VariableTok{a}\NormalTok{.}\AttributeTok{join}\NormalTok{(}\StringTok{''}\NormalTok{)}\OperatorTok{;}\NormalTok{                                       (}\DecValTok{10}\NormalTok{ symbols)}
\OperatorTok{\}}\NormalTok{                                                            (}\DecValTok{1}\NormalTok{ symbol)}
\end{Highlighting}
\end{Shaded}

\ldots{} which would be an extra \textbf{44} symbols (in total
\textbf{70}), and push us completely over the original string encoding
of \textbf{53} symbols. So, \emph{encoding language is important}.

Conversely, if ECMAScript 6.0 had introduced a function called
\texttt{abcdRepeater(n)} we'd have been able to do this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \AttributeTok{out}\NormalTok{() }\OperatorTok{\{}\NormalTok{                                             (}\DecValTok{7}\NormalTok{ symbols)}
    \ControlFlowTok{return} \AttributeTok{abcdRepeater}\NormalTok{(}\DecValTok{10}\NormalTok{)                                  (}\DecValTok{6}\NormalTok{ symbols)}
\OperatorTok{\}}\NormalTok{                                                            (}\DecValTok{1}\NormalTok{ symbol)}
\end{Highlighting}
\end{Shaded}

.. and re-encode to \textbf{14} symbols. Now, clearly there are some
problems with all this:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Clearly, \emph{language matters}: the Kolmogorov complexity is
  dependent on the language, and the features the language has built in.
\item
  The exact Kolmogorov complexity is uncomputable anyway (it's the
  \emph{theoretical} minimum program length). It's just a fairly
  abstract idea, so we shouldn't get too hung up on this. There is no
  function to be able to say, ``what's the Kolmogorov complexity of
  string X''
\item
  What is this new library function we've created? Is
  \texttt{abcdRepeater} going to be part of \emph{every} Javascript? If
  so, then we've shifted Codebase Risk away from ourselves, but we've
  pushed Communication Risk and Dependency Risk onto every \emph{other}
  user of Javascript. (Why these? Because \texttt{abcdRepeater} will be
  clogging up the documentation and other people will rely on it to
  function correctly.)
\item
  Are there equivalent functions for every single other string? If so,
  then compilation is no longer a tractable problem: is
  \texttt{return\ abcdRepeater(10)} correct code? Well, now we have a
  massive library of different \texttt{XXXRepeater} functions to compile
  against to see if it is\ldots{} So, what we \emph{lose} in Kolmogorov
  Complexity we gain in Runtime Complexity.
\item
  Language design, then, is about \emph{ergonomics}. After you have
  passed the relatively low bar of providing
  \href{https://en.wikipedia.org/wiki/Turing_completeness}{Turing
  Completeness}, the key is to provide \emph{useful} features that
  enable problems to be solved, without over-burdening the user with
  features they \emph{don't} need. And in fact, all software is about
  this.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{images/kite9/software-dependency-ergonomics.png}
\caption{Software Dependency Ergonomics: finding the sweet spot between
too many features and too few}
\end{figure}

\hypertarget{ergonomics-examined}{%
\section{Ergonomics Examined}\label{ergonomics-examined}}

Have a look at some physical tools, like a hammer, or spanner. To look
at them, they are probably \emph{simple} objects, obvious, strong and
dependable. Their entire behaviour is encapsulated in their form. Now,
if you have a drill or sander to hand, look at the design of this too.
If it's well-designed, then from the outside it is simple, perhaps with
only one or two controls. Inside, it is complex and contains a motor,
perhaps a transformer, and is maybe made of a hundred different
components.

But outside, the form is simple, and designed for humans to use. This is
\emph{\href{https://en.wikipedia.org/wiki/Human_factors_and_ergonomics}{ergonomics}}:

\begin{quote}
``Human factors and ergonomics (commonly referred to as Human Factors),
is the application of psychological and physiological principles to the
(engineering and) design of products, processes, and systems. The goal
of human factors is to reduce human error, increase productivity, and
enhance safety and comfort with a specific focus on the interaction
between the human and the thing of interest.'' - Human Factors and
Ergonomics, \emph{Wikipedia}
\end{quote}

\hypertarget{interfaces}{%
\subsection{Interfaces}\label{interfaces}}

The interface of a tool is the part we touch and interact with. By
striving for simplicity, the interface reduces Communication Risk.

The interface of a system expands when you ask it to do a wide variety
of things. An easy-to-use drill does one thing well: it turns drill-bits
at useful levels of torque for drilling holes and sinking screws. But if
you wanted it to also operate as a lathe, a sander or a strimmer (all
basically mechanical things going round) you would have to sacrifice the
ergonomic simplicity for a more complex interface, probably including
adapters, extensions, handles and so on.

So, we now have split complexity into two: - The inner complexity of the
tool (how it works internally, it's own Kolmogorov Complexity). - The
complexity of the instructions that we need to write to make the tool
work (the interface Kolmogorov Complexity).

\begin{figure}
\centering
\includegraphics{images/kite9/software-dependency-complexity.png}
\caption{Types of Complexity For a Software Dependency}
\end{figure}

\hypertarget{software-tools}{%
\subsection{Software Tools}\label{software-tools}}

In the same way as with a hand-tool, the bulk of the complexity of a
software tool is hidden behind it's interface. But, the more complex the
\emph{purpose} of the tool, the more complex the interface will be.

Software is not constrained by \emph{physical} ergonomics in the same
way as a tool is. But ideally, it should have conceptual ergonomics:
ideally, complexity is hidden away from the user behind the
\href{https://en.wikipedia.org/wiki/Application_programming_interface}{Application
Programming Interface (API)}. This is the familiar concept of
Abstraction we've already looked at.

That is, the tool should be as simple to use and understand as possible.
This is the
\href{https://en.wikipedia.org/wiki/Principle_of_least_astonishment}{Principal
Of Least Astonishment}:

\begin{itemize}
\tightlist
\item
  \textbf{The abstractions should map easily to how the user expects the
  tool to work.} For example, I \emph{expect} the trigger on a drill to
  start the drill turning.
\item
  \textbf{The abstractions should leverage existing idioms and
  knowledge.} In a new car, I \emph{expect} to know what the symbols on
  the dashboard mean, because I've driven other cars.
\item
  \textbf{The abstractions provide me with only the functions I need.}
  Because everything else is confusing and gets in the way.
\end{itemize}

The way to win, then, is to allow a language to be extensible as-needed
with features written by third parties. By supplying mechanisms for
extension a language can provide insurances against the Boundary Risk of
adopting it.

\hypertarget{types-of-software-dependencies}{%
\section{Types Of Software
Dependencies}\label{types-of-software-dependencies}}

There are lots of ways you can depend on software. Here though, we're
going to focus on just three main types: 1. \textbf{Code Your Own}:
write some code ourselves to meet the dependency. 2. \textbf{Software
Libraries}: importing code from the Internet, and using it in our
project. Often, libraries are Open Source (this is what we'll consider
here). 3. \textbf{Software as a Service}: calling a service on the
Internet, (probably via \texttt{http}) This is often known as
\href{https://en.wikipedia.org/wiki/Software_as_a_service}{SaaS, or
Software as a Service}.

All 3 approaches involve a different risk-profile. Let's look at each in
turn, from the perspective of which risks get mitigated, and which risks
are accentuated.

\hypertarget{code-your-own}{%
\subsection{1. Code Your Own}\label{code-your-own}}

Initially, writing our own code was the only game in town: when I
started programming, you had a user guide, BASIC and that was pretty
much it. Tool support was very thin-on-the-ground. Programs and
libraries could be distributed as code snippets \emph{in magazines}
which could be transcribed and run, and added to your program. This
spirit lives on somewhat in StackOverflow and JSFiddle, where you are
expected to ``adopt'' others' code into your own project.

One of the hidden risks of embarking on a code-your-own approach is that
the features you need are \emph{not} apparent from the outset. What
might appear to be a trivial implementation of some piece of
functionality can often turn into it's own industry as more and more
hidden Feature Risk is uncovered.

For example, as we discussed in our earlier treatment of Dead-End Risk,
building log-in screens \emph{seemed like a good idea}. However, this
gets out-of-hand fast when you need: - A password reset screen - To
email the reset links to the user - An email verification screen - A
lost account screen - Reminders to complete the sign up process -
\ldots{} and so on.

\begin{figure}
\centering
\includegraphics{images/kite9/software-dependency-code-your-own.png}
\caption{Code-Your-Own mitigates immediate feature risk, but at the
expense of schedule risk, complexity risk and communication risk. There
is also a hidden risk of features you don't yet know you need.}
\end{figure}

\hypertarget{unwritten-software}{%
\subsection{Unwritten Software}\label{unwritten-software}}

Sometimes, you will pick up a dependency on \emph{unwritten software}.
This commonly happens when work is divided amongst team members, or
teams.

\begin{figure}
\centering
\includegraphics{images/kite9/software-dependency-unwritten-1.png}
\caption{Sometimes, a module you're writing will depend on unwritten
code}
\end{figure}

If a component \textbf{A} of our project \emph{depends} on \textbf{B}
for some kind of processing, you might not be able to complete
\textbf{A} before writing \textbf{B}. This makes \emph{scheduling} the
project harder, and if component \textbf{A} is a risky part of the
project, then the chances are you'll want to mitigate risk there first.

But it also hugely increases Communication Risk because now you're being
asked to communicate with a dependency that doesn't really exist yet,
\emph{let alone} have any documentation.

There are a couple of ways to do this:

\begin{itemize}
\tightlist
\item
  \textbf{Standards}: If component \textbf{B} is a database, a queue,
  mail gateway or something else with a standard interface, then you're
  in luck. Write \textbf{A} to those standards, and find a cheap, simple
  implementation to test with. This gives you time to sort out exactly
  what implementation of \textbf{B} you're going for. This is not a
  great long-term solution, because obviously, you're not using the
  \emph{real} dependency- you might get surprised when the behaviour of
  the real component is subtly different. But it can reduce Schedule
  Risk in the short-term.
\item
  \textbf{Coding To Interfaces}: If standards aren't an option, but the
  surface area of \textbf{B} that \textbf{A} uses is quite small and
  obvious, you can write a small interface for it, and work behind that,
  using a \href{https://en.wikipedia.org/wiki/Mock_object}{Mock} for
  \textbf{B} while you're waiting for finished component. Write the
  interface to cover only what \textbf{A} \emph{needs}, rather than
  everything that \textbf{B} \emph{does} in order to minimize the risk
  of \href{https://en.wikipedia.org/wiki/Leaky_abstraction}{Leaky
  Abstractions}.
\end{itemize}

\begin{figure}
\centering
\includegraphics{images/kite9/software-dependency-unwritten-2.png}
\caption{Coding to a standard on an interface breaks the dependency on
unwritten software}
\end{figure}

\hypertarget{conways-law}{%
\subsection{Conway's Law}\label{conways-law}}

If the dependency is being written by another person, another team or in
another country, communication risks pile up. When this happens, you
will want to minimize \emph{as much as possible} the interface
complexity, since the more complex the interface, the worse the
Communication Risk will be. The tendency then is to make the interfaces
between teams or people \emph{as simple as possible}, modularizing along
these organisational boundaries.

In essence, this is
\href{https://en.wikipedia.org/wiki/Conway\%27s_law}{Conway's Law}:

\begin{quote}
``organizations which design systems \ldots{} are constrained to produce
designs which are copies of the communication structures of these
organizations.'' --- M. Conway, \emph{Conway's Law}
\end{quote}

\hypertarget{software-libraries}{%
\subsection{2. Software Libraries}\label{software-libraries}}

By choosing a particular software library, we are making a move on the
Risk Landscape in the hope of moving to place with more favourable
risks. Typically, using library code offers a Schedule Risk and
Complexity Risk Silver Bullet. But, in return we expect to pick up: -
Communication Risk: because we now have to learn how to communicate with
this new dependency. - Boundary Risk - because now are limited to using
the functionality provided by this dependency. We have chosen it over
alternatives and changing to something else would be more work and
therefore costly.

But, it's quite possible that we could wind up in a worse place than we
started out, by using a library that's out-of-date, riddled with bugs or
badly supported. i.e.~Full of new, hidden Feature Risk.

It's \emph{really easy} to make bad decisions about which tools to use
because the tools don't (generally) advertise their deficiencies. After
all, they don't generally know how \emph{you} will want to use them.

\hypertarget{software-libraries---hidden-risks}{%
\subsection{Software Libraries - Hidden
Risks}\label{software-libraries---hidden-risks}}

Currently, choosing software dependencies looks like a ``bounded
rationality''-type process:

\begin{quote}
``Bounded rationality is the idea that when individuals make decisions,
their rationality is limited by the tractability of the decision
problem, the cognitive limitations of their minds, and the time
available to make the decision.'' -
\href{https://en.wikipedia.org/wiki/Bounded_rationality}{Bounded
Rationality, \emph{Wikipedia}}
\end{quote}

Unfortunately, we know that most decisions \emph{don't} really get made
this way. We have things like
\href{https://en.wikipedia.org/wiki/Confirmation_bias}{Confirmation
Bias} (looking for evidence to support a decision you've already made)
and \href{https://en.wikipedia.org/wiki/Cognitive_inertia}{Cognitive
Inertia} (ignoring evidence that would require you to change your mind)
to contend with.

But, leaving that aside, let's try to build a model of what this
decision making process \emph{should} involve. Luckily, other authors
have already considered the problem of choosing good software libraries,
so let's start there.

In the table below, I am summarizing three different sources, which give
descriptions of which factors to look for when choosing open-source
libraries.

\begin{figure}
\centering
\includegraphics{images/generated/software_dependency_table_1-400dpi.png}
\caption{Software Dependencies}
\end{figure}

\href{https://www.software.ac.uk/resources/guides/defending-your-code-against-dependency-problems}{sd1
- Defending your code against dependency problems}
\href{https://stackoverflow.com/questions/2960371/how-to-choose-an-open-source-library}{sd2
- How to choose an open source library}
\href{https://www.forbes.com/sites/forbestechcouncil/2017/07/20/open-source-to-use-or-not-to-use-and-how-to-choose/2/\#39e67e445a8c}{sd3
- Open Source - To use or not to use}

Some take-aways:

\begin{itemize}
\tightlist
\item
  Feature Risk is a big concern. How can you be sure that the project
  will do what you want it to do ahead of schedule? Will it contain bugs
  or missing features? By looking at factors like \emph{release
  frequency} and \emph{size of the community} you get a good feel for
  this which is difficult to fake.
\item
  Boundary Risk is also very important. You are going to have to
  \emph{live} with your choices for the duration of the project, so it's
  worth spending the effort to either ensure that you're not going to
  regret the decision, or that you can change direction later.
\item
  Third is Communication Risk: how well does the project deal with it's
  users? If a project is ``famous'', then it has communicated its
  usefulness to a wide, appreciative audience. Avoiding Communication
  Risk is also a good reason to pick \emph{tools you are already
  familiar with}.
\end{itemize}

\hypertarget{complexity-risk}{%
\subsection{Complexity Risk?}\label{complexity-risk}}

One thing that none of the sources consider (at least from the outset)
is the Complexity Risk of using a solution: - Does it drag in lots of
extra dependencies that seem unnecessary for the job in hand? If so, you
could end up in
\href{https://en.wikipedia.org/wiki/Dependency_hell}{Dependency Hell},
with multiple, conflicting versions of libraries in the project. - Do
you already have a dependency providing this functionality? So many
times, I've worked on projects that import a \emph{new} dependency when
some existing (perhaps transitive) dependency has \emph{already brought
in the functionality}. For example, there are plenty of libraries for
\href{https://en.wikipedia.org/wiki/JSON}{JSON} marshalling, but if I'm
also using a web framework the chances are it already has a dependency
on one already. - Does it contain lots of functionality that isn't
relevant to the task you want it to accomplish? e.g.~Using Java when a
shell script would do (on a non-Java project)

To give an extreme example of this, I once worked on an application
which used \href{https://en.wikipedia.org/wiki/Hazelcast}{Hazlecast} to
cache log-in session tokens for a 3rd party datasource. But, the app is
only used once every month, and session IDs can be obtained in
milliseconds. So\ldots{} why cache them? Although Hazlecast is an
excellent choice for in-memory caching across multiple JVMs, it is a
complex piece of software (after all, it does lots of stuff). By doing
this, you have introduced extra dependency risk, cache invalidation
risks, networking risks, synchronisation risks and so on, for actually
no benefit at all\ldots{} Unless, it's about CV Building.

Sometimes, the amount of complexity \emph{goes up} when you use a
dependency for \emph{good reason}. For example, in Java, you can use
\href{https://en.wikipedia.org/wiki/Java_Database_Connectivity}{Java
Database Connectivity (JDBC)} to interface with various types of
database. \href{https://en.wikipedia.org/wiki/Spring_Framework}{Spring
Framework} (a popular Java library) provides a thing called a
\texttt{JDBCTemplate}. This actually makes your code \emph{more}
complex, and can prove very difficult to debug. However, it prevents
some security issues, handles resource disposal and makes database
access more efficient. None of those are essential to interfacing with
the database, but not using them is Technical Debt that can bite you
later on.

\begin{figure}
\centering
\includegraphics{images/kite9/software-dependency-library.png}
\caption{Software Libraries Risk Tradeoff}
\end{figure}

\hypertarget{software-as-a-service}{%
\section{3. Software as a Service}\label{software-as-a-service}}

Businesses opt for Software as a Service (SaaS) because: - It vastly
reduces the Complexity Risk they face in their organisations.
e.g.~managing the software or making changes to it. - Payment is usually
based on \emph{usage}, mitigating Schedule Risk. e.g.~Instead of having
to pay for in-house software administrators, they can leave this
function to the experts. - Potentially, you outsource the Operational
Risk to a third party. e.g.~ensuring availability, making sure data is
secure and so on.

SaaS is now a very convenient way to provide \emph{commercial} software.
Popular examples of SaaS might be
\href{https://en.wikipedia.org/wiki/Salesforce.com}{SalesForce}, or
\href{https://en.wikipedia.org/wiki/Gmail}{GMail}. Both of which follow
the commonly-used
\href{https://en.wikipedia.org/wiki/Freemium}{Freemium} model, where the
basic service is provided free, but upgrading to a paid account gives
extra benefits.

By providing the software on their own servers, the commercial
organisation has a defence against \emph{piracy}, as well as being able
to control the Complexity Risk of the their environment (e.g.~not having
to support \emph{every} version of the software that's ever been
released).

Let's again recap the risks raised in some of the available literature:

\begin{figure}
\centering
\includegraphics{images/generated/software_dependency_table_2-400dpi.png}
\caption{Software As A Service Dependencies}
\end{figure}

\href{https://www.zdnet.com/article/saas-checklist-nine-factors-to-consider-when-selecting-a-vendor/}{sd4
- Saas Checklist - Nine Factors to Consider}
\href{http://sandhill.com/article/how-to-evaluate-saas-vendors-five-key-considerations/}{sd5
- How to Evaluate Saas Vendors}

Some take-aways:

\begin{itemize}
\tightlist
\item
  Clearly, Operational Risk is now a big concern. By depending on a
  third-party organisation you are tying yourself to its success or
  failure in a much bigger way than just by using a piece of open-source
  software. What happens to data security, both in the data centre and
  over the internet?
\item
  With Feature Risk you now have to condend with the fact that the
  software will be upgraded \emph{outside your control}, and you may
  have limited control over which features get added or changed.
\item
  Boundary Risk is a also a different proposition: you are tied to the
  software provider by \emph{a contract}. If the service changes in the
  future, or isn't to your liking, you can't simply fork the code (like
  you could with an open source project).
\end{itemize}

\begin{figure}
\centering
\includegraphics{images/kite9/software-dependency-saas.png}
\caption{Risk Tradeoff From Using \_Software as a Service (SaaS)}
\end{figure}

\hypertarget{a-matrix-of-options}{%
\section{A Matrix of Options}\label{a-matrix-of-options}}

We've looked at just 3 different ways of providing a software
dependency: SaaS, Libraries and code-your-own.

But these are not the only ways to do it, and there's clearly no one
\emph{right} way. Although here we have looked just at ``Commercial
Saas'' and ``Free Open Source'', in reality, these are just points in a
two-dimensional space involving \emph{Pricing} and \emph{Hosting}.

Let's expand this view slightly and look at where different pieces of
software sit on these axes:

\begin{sidewaysfigure}
\centering
\includegraphics{images/generated/software_dependency_table_3_sideways-400dpi.png}
\caption{Software Dependencies, Pricing, Delivery Matrix Risk Profiles}
\end{sidewaysfigure}

\begin{itemize}
\tightlist
\item
  Where there is value in the
  \href{https://en.wikipedia.org/wiki/Network_effect}{Network Effect},
  it's often a sign that the software will be free, or open source:
  programming languages and Linux are the obvious examples of this. Bugs
  are easier to find when there are lots of eyes looking, and learning
  the skill to use the software has less Boundary Risk if you know
  you'll be able to use it at any point in the future.
\item
  At the other end of the spectrum, clients will happily pay for
  software if it clearly \textbf{reduces complexity}. Take
  \href{https://en.wikipedia.org/wiki/Amazon_Web_Services}{Amazon Web
  Services (AWS)}. The essential trade here is that you substitute the
  complexity of hosting and maintaining various pieces of software, in
  exchange for monthly payments (Funding Risk for you). Since the AWS
  \emph{interfaces} are specific to Amazon, there is significant
  Boundary Risk in choosing this option.
\item
  In the middle there are lots of \textbf{substitute options} and
  therefore high competition. Because of this, prices are pushed towards
  zero, and and therefore often advertising is used to monetarize the
  product. \href{https://en.wikipedia.org/wiki/Angry_Birds}{Angry Birds}
  is a classic example: initially, it had demo and paid versions,
  however
  \href{https://en.wikipedia.org/wiki/Rovio_Entertainment}{Rovio}
  discovered there was much more money to be made through advertising
  than from the
  \href{https://www.deconstructoroffun.com/blog/2017/6/11/how-angry-birds-2-multiplied-quadrupled-revenue-in-a-year}{paid-for
  app}.
\end{itemize}

\hypertarget{managing-risks}{%
\subsection{Managing Risks}\label{managing-risks}}

So far, we've considered only how the different approaches to Software
Dependencies change the landscape of risks we face to mitigate some
Feature Risk or other.

But with Software Dependencies we can construct dependency networks to
give us all kinds of features and mitigate all kinds of risk. That is,
\emph{the features we are looking for are to mitigate some kind of
risk}.

For example, I might start using
\href{https://en.wikipedia.org/wiki/WhatsApp}{WhatsApp} for example,
because I want to be able to send my friends photos and text messages.
However, it's likely that those same features are going to allow us to
mitigate Communication Risk and Coordination Risk when we're next trying
to meet up.

Let's look at some:

\begin{longtable}[]{@{}ll@{}}
\toprule
\begin{minipage}[b]{0.40\columnwidth}\raggedright
Risk\strut
\end{minipage} & \begin{minipage}[b]{0.55\columnwidth}\raggedright
Examples of Software Mitigating That Risk\strut
\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.40\columnwidth}\raggedright
Coordination Risk\strut
\end{minipage} & \begin{minipage}[t]{0.55\columnwidth}\raggedright
Calendar tools, Bug Tracking, Distributed Databases\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.40\columnwidth}\raggedright
Map-And-Territory-Risk\strut
\end{minipage} & \begin{minipage}[t]{0.55\columnwidth}\raggedright
The Internet, generally. Excel, Google, ``Big Data'', Reporting
tools\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.40\columnwidth}\raggedright
Schedule-Risk\strut
\end{minipage} & \begin{minipage}[t]{0.55\columnwidth}\raggedright
Planning Software, Project Mangement Software\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.40\columnwidth}\raggedright
Communication-Risk\strut
\end{minipage} & \begin{minipage}[t]{0.55\columnwidth}\raggedright
Email, Chat tools, CRM tools like SalesForce, Forums, Twitter,
Protocols\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.40\columnwidth}\raggedright
Process-Risk\strut
\end{minipage} & \begin{minipage}[t]{0.55\columnwidth}\raggedright
Reporting tools, online forms, process tracking tools\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.40\columnwidth}\raggedright
Agency-Risk\strut
\end{minipage} & \begin{minipage}[t]{0.55\columnwidth}\raggedright
Auditing tools, transaction logs, Timesheet software, HR Software\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.40\columnwidth}\raggedright
Operational-Risk\strut
\end{minipage} & \begin{minipage}[t]{0.55\columnwidth}\raggedright
Support tools like ZenDesk, Grafana, InfluxDB, Geneos\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.40\columnwidth}\raggedright
Feature-Risk\strut
\end{minipage} & \begin{minipage}[t]{0.55\columnwidth}\raggedright
Every piece of software you use!\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{back-to-ergonomics}{%
\section{Back To Ergonomics}\label{back-to-ergonomics}}

What's clear from this analysis is that software dependencies don't
\emph{conquer} any risk - the moves they make on the Risk Landscape are
\emph{subtle}. Whether or not you end up in a more favourable position
risk-wise is going to depend heavily on the quality of the execution and
the skill of the implementor.

In particular, \emph{choosing} dependencies can be extremely difficult.
As we discussed above, the usefulness of any tool depends on its fit for
purpose, it's \emph{ergonomics within a given context}. It's all too
easy to pick a good tool for the wrong job:

\begin{quote}
``I suppose it is tempting, if the only tool you have is a hammer, to
treat everything as if it were a nail.'' -
\href{https://en.wiktionary.org/wiki/if_all_you_have_is_a_hammer,_everything_looks_like_a_nail}{Abraham
Maslow, \emph{Toward a Psychology of Being}}
\end{quote}

With software dependencies, we often have to live with the decisions we
make for a long time. In my experience, given the Boundary Risks
associated with getting this wrong, not enough time is spent really
thinking about this in advance.

Let's take a closer look at this problem in the next section, Boundary
Risk.

\part{Preview}

book1/Part3.md practices/Estimates.md

\backmatter

\hypertarget{glossary}{%
\chapter{Glossary}\label{glossary}}

\hypertarget{abstraction}{%
\section{Abstraction}\label{abstraction}}

\hypertarget{feedback-loop}{%
\section{Feedback Loop}\label{feedback-loop}}

\hypertarget{goal-in-mind}{%
\section{Goal In Mind}\label{goal-in-mind}}

\hypertarget{internal-model}{%
\section{Internal Model}\label{internal-model}}

The most common use for Internal Model is to refer to the model of
reality that you or I carry around in our heads. You can regard the
concept of Internal Model as being what you \emph{know} and what you
\emph{think} about a certain situation.

Obviously, because we've all had different experiences, and our brains
are wired up differently, everyone will have a different Internal Model
of reality.

Alternatively, we can use the term Internal Model to consider other
viewpoints: - Within an organisation, we might consider the Internal
Model of a \emph{team of people} to be the shared knowledge, values and
working practices of that team. - Within a software system, we might
consider the Internal Model of a single processor, and what knowledge it
has of the world. - A codebase is a team's Internal Model written down
and encoded as software.

An internal model \emph{represents} reality: reality is made of atoms,
whereas the internal model is information.

\hypertarget{meet-reality}{%
\section{Meet Reality}\label{meet-reality}}

\hypertarget{risk}{%
\section{Risk}\label{risk}}

\hypertarget{attendant-risk}{%
\subsection{Attendant Risk}\label{attendant-risk}}

\hypertarget{hidden-risk}{%
\subsection{Hidden Risk}\label{hidden-risk}}

\hypertarget{mitigated-risk}{%
\subsection{Mitigated Risk}\label{mitigated-risk}}

\hypertarget{take-action}{%
\section{Take Action}\label{take-action}}

\end{document}  