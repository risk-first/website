"use strict";(globalThis.webpackChunkrf_website=globalThis.webpackChunkrf_website||[]).push([[4324],{28453:(e,i,t)=>{t.d(i,{R:()=>a,x:()=>r});var s=t(96540);const o={},n=s.createContext(o);function a(e){const i=s.useContext(n);return s.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function r(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),s.createElement(n.Provider,{value:i},e.children)}},37692:(e,i,t)=>{t.d(i,{A:()=>s});const s=t.p+"assets/images/refactoring-5c9f7c3cc4e924548cacac52698f3c07.svg"},44501:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"risks/Model-Risks/Complexity-Risk/Kolmogorov-Complexity","title":"Kolmogorov Complexity","description":"The standard Computer-Science definition of complexity is Kolmogorov Complexity.  This is:","source":"@site/docs/risks/Model-Risks/Complexity-Risk/Kolmogorov-Complexity.md","sourceDirName":"risks/Model-Risks/Complexity-Risk","slug":"/risks/Kolmogorov-Complexity","permalink":"/risks/Kolmogorov-Complexity","draft":false,"unlisted":false,"editUrl":"https://github.com/risk-first/website/blob/master/docs/risks/Model-Risks/Complexity-Risk/Kolmogorov-Complexity.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"Kolmogorov Complexity","slug":"/risks/Kolmogorov-Complexity"},"sidebar":"tutorialSidebar","previous":{"title":"Complexity Risk","permalink":"/risks/Complexity-Risk"},"next":{"title":"Connectivity As Complexity","permalink":"/risks/Connectivity"}}');var o=t(74848),n=t(28453);const a={sidebar_position:1,title:"Kolmogorov Complexity",slug:"/risks/Kolmogorov-Complexity"},r=void 0,c={},l=[{value:"Abstraction",id:"abstraction",level:3},{value:"Refactoring",id:"refactoring",level:3},{value:"Languages and Dependencies",id:"languages-and-dependencies",level:3}];function d(e){const i={a:"a",blockquote:"blockquote",code:"code",em:"em",h3:"h3",img:"img",p:"p",pre:"pre",strong:"strong",...(0,n.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(i.p,{children:["The standard Computer-Science definition of complexity is ",(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Kolmogorov_complexity",children:"Kolmogorov Complexity"}),".  This is:"]}),"\n",(0,o.jsxs)(i.blockquote,{children:["\n",(0,o.jsxs)(i.p,{children:['"...the length of the shortest computer program (in a predetermined programming language) that produces the object as output." - ',(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Kolmogorov_complexity",children:"Kolmogorov Complexity, Wikipedia"})]}),"\n"]}),"\n",(0,o.jsxs)(i.p,{children:["This is a fairly handy definition for us as it means that in writing software to solve a problem there is a lower bound on the size of the software we write.  While in practice this is pretty much impossible to quantify, that doesn't really matter:  here I want to focus on the techniques for ",(0,o.jsx)(i.em,{children:"moving towards that minimum"}),"."]}),"\n",(0,o.jsx)(i.p,{children:"Let's say we wanted to write a JavaScript program to output this string:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-javascript",children:"abcdabcdabcdabcdabcdabcdabcdabcdabcdabcd\n"})}),"\n",(0,o.jsx)(i.p,{children:"We might choose this representation:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-javascript",children:' \nfunction out() {                                      (7 )\n    return "abcdabcdabcdabcdabcdabcdabcdabcdabcdabcd" (45)\n}                                                     (1 )\n                                               (total: 53)\n'})}),"\n",(0,o.jsxs)(i.p,{children:["The numbers in brackets on the right indicate how many symbols each line contains.  In total, this code block contains ",(0,o.jsx)(i.strong,{children:"53 symbols"})," if you count ",(0,o.jsx)(i.code,{children:"function"}),", ",(0,o.jsx)(i.code,{children:"out"})," and ",(0,o.jsx)(i.code,{children:"return"})," as one symbol each."]}),"\n",(0,o.jsx)(i.p,{children:"But, if we write it like this:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-javascript",children:'const ABCD="abcd";                                    (11)\n\nfunction out() {                                      (7 )\n    return ABCD+ABCD+ABCD+ABCD+ABCD+ABCD+ABCD+        (16)\n        ABCD+ABCD+ABCD;                               (6 )\n}                                                     (1 )\n                                               (total: 41)\n'})}),"\n",(0,o.jsxs)(i.p,{children:["With this version, we now have ",(0,o.jsx)(i.strong,{children:"41 symbols"})," (",(0,o.jsx)(i.code,{children:"ABCD"})," is a single symbol - it's just a name).  And with this version:"]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-javascript",children:'const ABCD="abcd";                                    (11)\n\nfunction out() {                                      (7 )\n    return ABCD.repeat(10)                            (7 )\n}                                                     (1 )\n                                               (total: 26)\n'})}),"\n",(0,o.jsxs)(i.p,{children:["... we have ",(0,o.jsx)(i.strong,{children:"26 symbols"}),"."]}),"\n",(0,o.jsx)(i.h3,{id:"abstraction",children:"Abstraction"}),"\n",(0,o.jsxs)(i.p,{children:["What's happening here is that we're ",(0,o.jsx)(i.em,{children:"exploiting a pattern"}),": we noticed that ",(0,o.jsx)(i.code,{children:"abcd"})," occurs several times, so we defined it a single time and then used it over and over, like a stamp.  This is called ",(0,o.jsx)(i.a,{href:"/tags/Abstraction",children:"abstraction"}),"."]}),"\n",(0,o.jsxs)(i.p,{children:["By applying abstraction, we can improve in the direction of the Kolmogorov lower bound.  By allowing ourselves to say that ",(0,o.jsx)(i.em,{children:"symbols"})," (like ",(0,o.jsx)(i.code,{children:"out"})," and ",(0,o.jsx)(i.code,{children:"ABCD"}),") are worth one complexity point, we've allowed that we can be descriptive in naming ",(0,o.jsx)(i.code,{children:"function"})," and ",(0,o.jsx)(i.code,{children:"const"}),".  Naming things is an important part of abstraction, because to use something, you have to be able to refer to it."]}),"\n",(0,o.jsxs)(i.p,{children:["Generally, the more complex a piece of software is, the more difficulty users will have ",(0,o.jsx)(i.a,{href:"/tags/Internal-Model-Risk",children:"understanding it"}),", and the more work developers will have changing it."]}),"\n",(0,o.jsxs)(i.p,{children:["Although we should prefer the third version of our code over either the first or second (because of its brevity) we could go further down into ",(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Code_golf",children:"Code Golf"})," territory.  The following javascript program plays ",(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Fizz_buzz",children:"FizzBuzz"})," up to 100, but is less readable than you might hope."]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-javascript",children:"for(i=0;i<100;)document.write(((++i%3?'':'Fizz')+     \n(i%5?'':'Buzz')||i)+\"<br>\")\n                                               (total: 62)\n"})}),"\n",(0,o.jsxs)(i.p,{children:["So there is at some point a trade-off to be made between ",(0,o.jsx)(i.a,{href:"/tags/Complexity-Risk",children:"Complexity Risk"})," and ",(0,o.jsx)(i.a,{href:"/tags/Communication-Risk",children:"Communication Risk"}),". That is, after a certain point, reducing Kolmogorov Complexity further risks making the program less intelligible."]}),"\n",(0,o.jsx)(i.h3,{id:"refactoring",children:"Refactoring"}),"\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.img,{alt:"Using Refactoring and Abstraction to reduce Complexity",src:t(37692).A+"",width:"1427",height:"376"})}),"\n",(0,o.jsxs)(i.p,{children:["Abstraction is therefore a key tool in the battle against ",(0,o.jsx)(i.a,{href:"/tags/Complexity-Risk",children:"Complexity Risk"}),": it allows us to jettison repetition.  But, as the code-golf example shows, you can go too far.  So an important part of software development is picking the ",(0,o.jsx)(i.em,{children:"right"})," abstractions:  ones that are useful, durable and pervasive."]}),"\n",(0,o.jsxs)(i.p,{children:["Time spent replacing poor abstractions with better ones is called ",(0,o.jsx)(i.a,{href:"/tags/Refactoring",children:"refactoring"}),"."]}),"\n",(0,o.jsxs)(i.p,{children:["The above diagram demonstrates that a key practice in battling ",(0,o.jsx)(i.a,{href:"/tags/Complexity-Risk",children:"Complexity Risk"})," is choosing ",(0,o.jsx)(i.strong,{children:"a minimal set of useful abstractions"}),".  The attendant risk in doing that work (the downside) is the ",(0,o.jsx)(i.em,{children:"time spent doing it"}),". That is, ",(0,o.jsx)(i.a,{href:"/tags/Schedule-Risk",children:"Schedule Risk"}),"."]}),"\n",(0,o.jsxs)(i.p,{children:["Sometimes it is better to have an ok-ish abstraction ",(0,o.jsx)(i.em,{children:"now"})," rather than a brilliant abstraction ",(0,o.jsx)(i.em,{children:"too late"}),"."]}),"\n",(0,o.jsx)(i.h3,{id:"languages-and-dependencies",children:"Languages and Dependencies"}),"\n",(0,o.jsxs)(i.p,{children:["The above Javascript example also demonstrates a second way in which we can manage ",(0,o.jsx)(i.a,{href:"/tags/Complexity-Risk",children:"Complexity Risk"}),"."]}),"\n",(0,o.jsxs)(i.p,{children:["In the third version of the program, we used the method ",(0,o.jsx)(i.code,{children:".repeat()"}),", which allowed us to save a further 16 symbols."]}),"\n",(0,o.jsxs)(i.p,{children:[(0,o.jsx)(i.code,{children:".repeat()"})," is a recent addition to Javascript, added in ES6.  What this shows is that the Kolmogorov complexity of a program is actually ",(0,o.jsx)(i.em,{children:"heavily dependent"})," on the features of the programming language:  using ES6-Javascript allows us to produce simpler programs than before."]}),"\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.img,{alt:"Using Libraries and Languages to reduce Complexity Risk",src:t(68103).A+"",width:"1602",height:"453"})}),"\n",(0,o.jsxs)(i.p,{children:["So as the above diagram shows, we can also reduce ",(0,o.jsx)(i.a,{href:"/tags/Complexity-Risk",children:"Complexity Risk"})," via ",(0,o.jsx)(i.a,{href:"/tags/Dependency-Adoption",children:"languages and libraries"}),".   This doesn't come without a cost, though.  We are trading-off our own code's ",(0,o.jsx)(i.a,{href:"/tags/Complexity-Risk",children:"Complexity Risk"})," but adding ",(0,o.jsx)(i.a,{href:"/tags/Dependency-Risks",children:"Dependency Risks"})," instead."]})]})}function h(e={}){const{wrapper:i}={...(0,n.R)(),...e.components};return i?(0,o.jsx)(i,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},68103:(e,i,t)=>{t.d(i,{A:()=>s});const s=t.p+"assets/images/libraries-74de04a04c75a75a5a788e7941e431d4.svg"}}]);