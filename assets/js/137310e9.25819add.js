"use strict";(globalThis.webpackChunkrf_website=globalThis.webpackChunkrf_website||[]).push([[3792],{26147:(e,i,n)=>{n.d(i,{A:()=>s});const s=n.p+"assets/images/modularisation-747767d3cb51d78abba0d37ab44f0078.svg"},28453:(e,i,n)=>{n.d(i,{R:()=>r,x:()=>a});var s=n(96540);const t={},o=s.createContext(t);function r(e){const i=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(o.Provider,{value:i},e.children)}},30044:(e,i,n)=>{n.d(i,{A:()=>s});const s=n.p+"assets/images/connectivity_2-3ec55e09f36483b57adf5783091c932e.svg"},30646:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>h,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"risks/Model-Risks/Complexity-Risk/Connectivity","title":"Connectivity As Complexity","description":"A second useful measure of complexity comes from graph theory, and that is the connectivity of a graph:","source":"@site/docs/risks/Model-Risks/Complexity-Risk/Connectivity.md","sourceDirName":"risks/Model-Risks/Complexity-Risk","slug":"/risks/Connectivity","permalink":"/risks/Connectivity","draft":false,"unlisted":false,"editUrl":"https://github.com/risk-first/website/blob/master/docs/risks/Model-Risks/Complexity-Risk/Connectivity.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"Connectivity As Complexity","slug":"/risks/Connectivity"},"sidebar":"tutorialSidebar","previous":{"title":"Kolmogorov Complexity","permalink":"/risks/Kolmogorov-Complexity"},"next":{"title":"Analogies For Complexity","permalink":"/risks/Complexity-Analogies"}}');var t=n(74848),o=n(28453);const r={sidebar_position:2,title:"Connectivity As Complexity",slug:"/risks/Connectivity"},a=void 0,h={},c=[{value:"Hierarchies and Modularisation",id:"hierarchies-and-modularisation",level:3}];function l(e){const i={a:"a",blockquote:"blockquote",code:"code",em:"em",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.p,{children:"A second useful measure of complexity comes from graph theory, and that is the connectivity of a graph:"}),"\n",(0,t.jsxs)(i.blockquote,{children:["\n",(0,t.jsxs)(i.p,{children:['"...the minimum number of elements (nodes or edges) that need to be removed to disconnect the remaining nodes from each other" - ',(0,t.jsxs)(i.a,{href:"https://en.wikipedia.org/wiki/Connectivity_(graph_theory)",children:["Connectivity, ",(0,t.jsx)(i.em,{children:"Wikipedia"})]})]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.img,{alt:"Graph 1, 2-Connected",src:n(92719).A+"",width:"1200",height:"590"})}),"\n",(0,t.jsxs)(i.p,{children:["To see this in action, have a look at the graph above.  It has 10 vertices, labelled ",(0,t.jsx)(i.strong,{children:"a"})," to ",(0,t.jsx)(i.strong,{children:"j"}),", and it has 15 edges (or links) connecting the vertices together.  If any single edge were removed from the diagram above, the 10 vertices would still be linked together.   Because of this, we can say that the graph is ",(0,t.jsx)(i.em,{children:"2-connected"}),".   That is, to disconnect any single vertex, you'd have to remove ",(0,t.jsx)(i.em,{children:"at least"})," two edges."]}),"\n",(0,t.jsxs)(i.p,{children:["As a slight aside, let's consider the ",(0,t.jsx)(i.strong,{children:"Kolmogorov Complexity"})," of this graph, by inventing a mini-language to describe graphs.  It could look something like this:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-javascript",children:"<item> : [<item>,]* <item>    # Indicates that the item \n                              # before the colon \n                              # has a connection to all \n                              # the items after the colon\n"})}),"\n",(0,t.jsx)(i.p,{children:"So our graph could be defined like this:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-javascript",children:"a: b,c,d\nb: c,f,e\nc: f,d\nd: j\ne: h,j\nf: h\ng: j\nh: i\ni: j                                                  \n                                               (total: 39)\n"})}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.img,{alt:"Graph 2, 1-Connected",src:n(30044).A+"",width:"1200",height:"430"})}),"\n",(0,t.jsxs)(i.p,{children:["In the graph above, I've removed 6 of the edges.  Now, we're in a situation where if any single edge is removed, the graph becomes ",(0,t.jsx)(i.em,{children:"unconnected"}),".  That is, it's broken into distinct chunks.  So, it is ",(0,t.jsx)(i.em,{children:"1-connected"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["The second graph is clearly simpler than the first.  And, we can show this by looking at the ",(0,t.jsx)(i.strong,{children:"Kolmogorov Complexity"})," in our little language:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-javascript",children:"a: d,g\nb: f\nc: d,f\nd: j\nf: h\ne: h\nh: i                                                  \n                                               (total: 25)\n"})}),"\n",(0,t.jsxs)(i.p,{children:["So for defining our graphs, ",(0,t.jsx)(i.strong,{children:"Connectivity"})," is also ",(0,t.jsx)(i.strong,{children:"Complexity"}),"."]}),"\n",(0,t.jsx)(i.p,{children:"This carries over into software too:  heavily connected code is more complex than less-connected code.   It's also harder to reason about and work with because changing one module potentially impacts many others.  Let's dig into this further."}),"\n",(0,t.jsx)(i.h3,{id:"hierarchies-and-modularisation",children:"Hierarchies and Modularisation"}),"\n",(0,t.jsx)(i.p,{children:"In the second graph, I've arranged it as a hierarchy (which I can do trivially now that it's only 1-connected).  For 10 vertices, we need 9 edges to connect everything up.  It's always:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-javascript",children:"  edges = vertices - 1\n"})}),"\n",(0,t.jsxs)(i.p,{children:["Note that I could pick any hierarchy here:  I don't have to start at ",(0,t.jsx)(i.strong,{children:"c"})," (although it has the nice property that it has two roughly equally-sized sub-trees attached to it)."]}),"\n",(0,t.jsxs)(i.p,{children:["How does this help us?   Imagine if ",(0,t.jsx)(i.strong,{children:"a"})," - ",(0,t.jsx)(i.strong,{children:"j"})," were modules of a software system and the edges of the graph showed communications between the different sub-systems.  In the first graph, we're in a worse position:"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Who's in charge?  What deals with what?"}),"\n",(0,t.jsx)(i.li,{children:"Can I isolate a component and change it safely?"}),"\n",(0,t.jsx)(i.li,{children:"What happens if one component disappears?"}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"The second graph is easier to reason about because of the reduced number of connections and the new hierarchy of organisation."}),"\n",(0,t.jsxs)(i.p,{children:["On the down-side, perhaps our messages have farther to go now:  in the original, ",(0,t.jsx)(i.strong,{children:"i"})," could send a message straight to ",(0,t.jsx)(i.strong,{children:"j"}),", but now we have to go all the way via ",(0,t.jsx)(i.strong,{children:"c"}),".   But this is the basis of ",(0,t.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Modular_programming",children:"Modularisation"})," and ",(0,t.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Hierarchy",children:"Hierarchy"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["Secondly, it's not apparent to ",(0,t.jsx)(i.strong,{children:"i"})," that ",(0,t.jsx)(i.strong,{children:"j"})," ",(0,t.jsx)(i.em,{children:"even exists"}),": we have hidden the modules from each other.  For anything that ",(0,t.jsx)(i.strong,{children:"i"})," needed to send to ",(0,t.jsx)(i.strong,{children:"j"}),", ",(0,t.jsx)(i.strong,{children:"i"})," must be able to send to ",(0,t.jsx)(i.strong,{children:"c"})," instead."]}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.img,{alt:"Modularisation and Hierarchy",src:n(26147).A+"",width:"1534",height:"453"})}),"\n",(0,t.jsxs)(i.p,{children:["The trade-off of modularisation/hierarchy is shown in the above diagram, and it's our third tool for battling ",(0,t.jsx)(i.a,{href:"/tags/Complexity-Risk",children:"Complexity Risk"}),"."]}),"\n",(0,t.jsx)(i.p,{children:"But we don't just see this in software, it's everywhere in our lives:  societies, business, and living organisms all use this technique.  For example in our bodies we have:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Organelles"})," - such as ",(0,t.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Mitochondrion",children:"Mitochondria"}),", contained in..."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Cells"})," - such as blood cells, nerve cells, skin cells in the ",(0,t.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/List_of_distinct_cell_types_in_the_adult_human_body",children:"Human Body"}),", inside..."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Organs"})," - like hearts livers, brains etc, held within..."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Organisms"})," - like you and me."]}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:["The great complexity-reducing mechanism of modularisation is that ",(0,t.jsx)(i.em,{children:"you only have to consider your local environment"}),"."]})]})}function d(e={}){const{wrapper:i}={...(0,o.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},92719:(e,i,n)=>{n.d(i,{A:()=>s});const s=n.p+"assets/images/connectivity_1-5ea432e7f4207473c7899fa5cad90884.svg"}}]);